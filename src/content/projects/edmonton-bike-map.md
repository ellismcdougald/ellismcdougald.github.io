---
title: "Edmonton Bike Map"
tech: "Svelte · Go · PostgreSQL"
---

# Overview

With this project I set out to build something that would be truly useful for myself and for others. When there isn't snow on the ground, I like to ride my bike around Edmonton for both leisure and for transportation. Often I am riding a route I know well, like my ride to the university. But sometimes I need to ride someplace I haven't ridden before. Finding a safe and comfortable bike route from one place to another isn't as simple as plugging in start and end addresses into Google Maps. I often find myself piecing together a route using a combination of a map of Edmonton's bike infastructure and Google Maps streetview to verify the suitability of different routes. Some roads are simply unsafe for bikes, while others may be uncomfortable. Even where bike infastructure is available, an adjacent quiet residential street might be more comfortable to ride on.

This website provides bike-specific routing and direction for Edmonton cyclists. It allows users to leave reviews on roads, paths, and bike lanes. These reviews then inform the routing algorithm, directing cyclists towards routes that are highly rated by themselves and others.

# Tech Stack

I initially started this website with plain old HTML/CSS/JS, since I was not envisioning a sophisticated interface. But as the frontend started to grow, I quickly began to miss the modularity that component-based frameworks offer. I decided to use **Svelte** because it would allow for better organization and provides easy routing for the different pages of the website while being very light weight.

I wanted to try **Golang** because I had heard good things about it. I like it a lot: it feels very simple to use while still being very powerful. Go often made implementation details feel very easy. For instance, the standard library makes it easy to set up an HTTP server and working with JSON data was much simpler than I expected due to built-in struct tags.

# Challenges

### Routing and Personalization

Routing uses Dijkstra's algorithm to find a shortest path. Our OpenStreetMaps data (nodes and ways) is used to build a graph representation of the Edmonton transportation network. Ways, which comprise of a sequence of nodes, are divided into their constituent edges. Each edge has an associated weight. The base weight is simply the length (distance) of the edge. But this is then augmented with additional information for the way that the edge belongs to, such as road type (residential, pathway, cycleway, etc), surface type (concrete, gravel, dirt, etc), and bike-friendliness. Our OpenStreetMaps data includes information on whether a road is designated for bicycles or is part of Edmonton's bike network, allowing us to easily determine whether it is particularly suited for bicycles or not.

#### Reviews

One of the key features of this project is that routing is informed by user reviews. This recognizes the fact that basic descriptive information for a road, such as whether or not it is designated part of the city's bike network, does not provide enough information to determine whether cyclists will actually want to use that road. This is especially useful for roads that are not part of the city's bicycle infastructure: any significant trip on a bike will inevitably require riding on the road and user reviews can help guide cyclists towards safe and comfortable roads to ride on. For instance, most cyclists will prefer a quiet, wide residential road over an alternative residential road with lots of cars parked on the street and significant traffic using it as a shortcut. But basic road data would view both these residential roads as more or less equivalent. User reviews lets us incorporate additional information into routing and allow for a routing engine that gets better and better over time and as the user base expands!

The routing algorithm applies a review multiplier to the edge weights. This review multiplier is personalized to the user. If the user has left a review for a particular road, then the review multiplier is calculated solely using their review (reviews by other users are not considered). If a user has not left a review for a particular road, then the review multiplier is based on the average rating of other reviews. Confidence increases as more reviews are left: the review multiplier will be small if there is only one review but larger if there are many reviews.

Since the review multiplier depends on the user making the request, review multipliers must be computed at the time of the request. They cannot be baked into the network like the other adjustments are. To accomplish this, the routing algorithm uses a `MultiplierProvider` object that provides a `MultiplierFor(wayID, userID)` method for the routing algorithm to use. Encapsulating the review multiplier logic into a separate object reduces coupling of routing to reviews and makes it easy to extend the multiplier to consider additional information in the future. For example, we may later want to consider a user's specific preferences in routing. User A may ride a rugged commuter with wider tires that can handle a variety of surfaces while User B rides a road bike that is best kept to the pavement. User A wants the best route regardless of surface type, while User B only wants routes that stick to the pavement. In order to accomplish this, we only need to modify the `MultiplierProvider` object to consider this information when computing the multiplier without touching the routing algorithm at all.

### Viewing way details on map clicks

The user can click on a road/path on a map in order to bring up details for that particular way, such as its name, type, surface, and user reviews. Identifying a way from a map click proved to be a bit challenging.

#### My First Approach

Leaflet allows you to load layers onto the map. These layers can be used to draw lines or highlight particular roads on the map. To give you an example, displaying routes on the map is done using a layer. I added a layer which I called the "info layer". This was an invisible layer made up of every way in my dataset. Nothing showed on the map, but this layer was clickable. The clicks would map to the particular feature that was clicked, solving my problem. I proceeded with this approach and moved on to other features, but I sometimes noticed that the map was slow and laggy. But this was only sometimes and it wasn't a major issue, so I decided to leave it for the time being.

This approach required fetching all the ways from the database in order to populate the info layer. There are nearly 90,000 ways in the database, so fetching them all and then loading them onto the map took a couple seconds. Initially, this loading was done on the client in the background, so the map would display and then a couple seconds later the info layer would finish loading and map clicks would become enabled. This load time was not unreasonable, so I didn't see this as a significant issue at the time. Later on, I decided to take advantage of Svelte's server-side rendering support by loading the ways data on the server. Now that the page load was blocked by this ~2 second fetch (rather than the map showing immediately and then the info layer becoming active soon after), the delay was much more noticable. I initially pursued another band-aid fetch: Svelte allows me to return the ways as a promise in order to immediately display the map before loading the info layer later (amounting to the same behaviour as when I was loading ways on the client). But seeing how long this load actually took had me realize that loading in ~90,000 ways every time the map is displayed is inefficient and was probably the cause of the lagginess I was experiencing with the map. I needed a better solution.

#### A Better Solution

I soon realized that the better solution was a very simple one: when a user clicks on the map, pass the coordinates to the backend and get the nearest way to that click. This completely eliminated the step of loading in all ways. The difference in data exchange between these two approaches is HUGE: we can either fetch every single way in the entire database or we can send the coordinates and receive just a single way in response. Even with the first approach, once a way was clicked I still needed to fetch the reviews for that way in order to display the sidebar. In hindsight, this newer approach was both simpler and clearly better. The only thing I needed to get right was my method of identifying the nearest way to the map click coordinates. This was fairly straightforward, since Leaflet gives me the click coordinates as a latitude and longitude and my OpenStreetMap nodes are made up of a latitude and longitude. But a way is made up of many nodes. My initial implementation to test the approach used the simplest possible algorithm: identify the nearest node based on the coordinates, then just return whichever way comes first that contains that node. This worked fairly well in most cases, but I often had to try clicking at different points on a road in order to select the road I wanted rather than an intersecting street or parallel sidewalk, due to the imprecision of my simple algorithm. To improve accuracy, I needed to find the _way_ with the smallest distance to the click coordinates, not the closest node and then picking a way based on that. I was able to do this efficiently using **PostGIS**, an extension for PostgreSQL that added special geographic functionality to my database. PostGIS provides functions for computing the distance between geometries, including ways. This allowed me to build a more sophisticated query that takes the ten nearest nodes to the click coordinates, computes the distance between the click coordinates and every way that contains at least one of those nodes, and then chooses the way with the smallest distance. The key here is that we are computing distance based on any point on that way, not just the OSM nodes that it contains. PostGIS also enables the use of Generalized Search Tree (GiST) indexes to speed up these geographic computations, making this query near-instantaneous.

#### Results

After integrating PostGIS, this feature worked exactly as I hoped it would. We avoid loading in the entire set of ways, saving loading time and data exchange. The map clicks are super fast and super accurate. To see just how accurate the map clicks are, go the map and find an intersection. Click directly in the middle of that intersection and see which road is selected (it could be either one, depending on exactly where you ended up clicking). Now move your cursor just slightly in the direction of the road that was not selected and click again. You'll see that you barely have to move your cursor towards the other road in order to select it.

### Offering Multiple Route Options

I wanted to offer the user multiple route options, like Google or Apple Maps do for driving. This proved to be a bit trickier than I expected, although the solution I arrived on ended up being fairly simple in the end. I started out by offering a single route, which was the "shortest" path found by Dijkstra's algorithm. This is not the true shortest path in terms of raw distance, but rather the lowest combined edge weight path. Edge weights are computed by applying modifiers to the raw distance according to factors like speed limit, road type, and status in Edmonton's designated bike network.

#### My First Approach

To extend this to multiple routes, my first instinct was to simply use a k-shortest path algorithm. Instead of finding the single shortest path, I'll simply find the three shortest path and display them all. There are a couple of big problems with this though. First, in many situations the alternative paths will just be variants of the actual shortest path. So the route might be nearly identical except that the second best route deviates from the best route for a single block. You might have experienced this with Google Maps before.

<img src="/googlemaps-ex.png" alt="Google Maps example" width="600" />

The even larger issue is performance. For V vertices and E edges, Dijkstra is O((V+E)log(V)) to find a single shortest path. Yen's Algorithm is a k-shortest path algorithm that uses Dijkstra (or another routing algorithm) repeatedly to find multiple paths. It will find a shortest path with Dijkstra. For every node in that path, it will find a new path from that node to the target and combine it with the previous path to that node to form a new path. This will yield the second shortest path. To find more than 2 paths, it will repeat the process using every previous path it has found. This is O(K \* V \* (V + E) log(V)) to find k shortest paths. There are close to 500,000 nodes in the Edmonton network. Of course, a path is not going to use all of those, but a path can easily contain many thousand nodes and it becomes easy to see how the time performance will absolutely explode as soon as you try to look for more than one path. I tried Yen's algorithm and it could take 10-15 seconds to find just two routes for a start and end point for which we could find one route instantaneously. Clearly, Yen's algorithm is not feasible here as it is simply too slow. It was a bit of a surprise to me just how extreme the difference in time complexity is when you move from single shortest path to k shortest paths. I had naively thought initially that the time increase would likely be linear in k: I thought that if we want to find the three shortest paths, it will probably take about 3x as long as to find the single shortest path. I was very wrong. Of course, when you think about what Yen's algorithm has to do in order to find the next shortest path, the dramatic increase in time requirements makes complete sense.

#### A Better Solution

Thankfully, the solution to achieve what I wanted ended up being fairly simple. I don't actually want to find the k shortest paths. As discussed before, this is likely to lead to very similar variants in routes that don't offer true choice for the user. I actually want to show the _best path_, as I already was, as well as a couple alternative paths that are _pretty good_ but most importantly are fairly different from the best path. This gives the user some real choice: maybe they want to take a route that is more scenic or avoid a particular area altogether. The solution that allows us to accomplish this is a method that we'll call 'Dijkstra with pertubations.' We find the shortest path as usual, then modify the weights of the ways involved in that path to discourage revisiting them. Then we simply run Dijkstra's again with these new weights. We encourage the algorithm to find signficantly different routes (without forcing it-- it can still revisit ways if they are clearly better than any alternative) without adding any real computational complexity. This algorithm really is O(k \* (V + E)log(k)), so finding three routes only takes about three times as long. It is fast and does a pretty good job of identifying some alternative routing options, making it a great solution to the problem.
